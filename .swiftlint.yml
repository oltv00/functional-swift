whitelist_rules:
  - strict_fileprivate
  # `fileprivate` should be avoided.
  #  â†“fileprivate extension String {}
  #
  #  extension String {
  #      â†“fileprivate func Something(){}
  #  }

  - empty_string
  # Prefer checking `isEmpty` over comparing `string` to an empty string literal.
  #  myStringâ†“ == ""
  #
  #  myStringâ†“ != ""

  - modifier_order
  # Modifier order should be consistent.
  #  public class Foo {
  #    static public let bar = 42
  #  }
  #
  #  public class Foo {
  #      static public var bar: Int {
  #           return 42
  #      }
  #  }
  #
  #
  #  public class Foo {
  #      class public var bar: Int {
  #           return 42
  #      }
  #  }
  #
  #  public class RootFoo {
  #      class public var foo: String {
  #          return "foo"
  #      }
  #  }



  - unneeded_break_in_switch
  # Avoid using unneeded break statements.
  #  switch foo {
  #  case .bar:
  #    something()
  #    â†“break
  #  }



  - switch_case_alignment
  # Case statements should vertically align with their enclosing switch statement, or indented if configured otherwise.
  #  switch someInt {
  #      â†“case 0:
  #        print('Zero')
  #      â†“case 1:
  #        print('One')
  #      â†“default:
  #        print('Some other number')
  #  }
  #
  #  switch someBool {
  #  case true:
  #    print('red')
  #    â†“case false:
  #      print('blue')
  #  }



  - weak_delegate
  # Delegates should be weak to avoid reference cycles.
  #
  # â†“var delegate: SomeProtocol?
  #
  # â†“var scrollDelegate: ScrollDelegate?



  - closing_brace
  # Closing brace with closing parenthesis should not have any whitespaces in the middle.
  #
  # [].map({ â†“} )
  
  
  
  - closure_end_indentation
  # Closure end should have the same indentation as the line that started it.
  #
  # SignalProducer(values: [1, 2, 3])
  #        .startWithNext { number in
  #            print(number)
  #     â†“}
  #
  # return match(pattern: pattern, with: [.comment]).flatMap { range in
  #        return Command(string: contents, range: range)
  #        â†“}.flatMap { command in
  #        return command.expand()
  #     â†“}
  
  
  
  - closure_parameter_position
  # Closure parameters should be on the same line as opening brace.
  #
  # [1, 2].map {
  #    â†“number in
  #    number + 1
  #  }
  #
  # [1, 2].map {
  #   â†“number -> Int in
  #   number + 1
  # }
  
  
  
  - closure_spacing
  # Closure expressions should have a single space inside each brace.
  #
  # [].filter(â†“{$0.contains(location)})
  #
  # [].map(â†“{$0})
  
  
  
  - colon
  # Colons should be next to the identifier when specifying a type and next to the key in dictionary literals.
  # 
  # let â†“abc:Void
  #
  # let â†“abc:  Void
  #
  # let â†“abc :Void
  #
  # let â†“abc : Void
  #
  # let â†“abc : [Void: Void]
  #
  # func abc(â†“def:Void) {}
  #
  # func abc(def: Void, â†“ghi :Void) {}
  #
  # let abc = [Voidâ†“ : Void]()
  #
  # let abc = [Voidâ†“:  Void]()
  #
  # let abc = [1: [3â†“ : 2], 3: 4]
  
  
  
  - comma
  # There should be no space before and one after any comma.
  #
  # func abc(a: Stringâ†“ ,b: String) { }
  #
  # func abc(a: Stringâ†“ ,b: Stringâ†“ ,c: Stringâ†“ ,d: String) { }
  #
  # enum a { case aâ†“ ,b }
  #
  # let result = plus(
  #     first: 3â†“ , // #683
  #     second: 4
  # )
  
  
  
  - compiler_protocol_init
  # The initializers declared in compiler protocols such as `ExpressibleByArrayLiteral` shouldn't be called directly.
  #
  # let set = â†“Set(arrayLiteral: 1, 2)
  #
  # let set = â†“Set.init(arrayLiteral: 1, 2)
  
  
  
  - control_statement
  # if, for, while, do, guard, switch statements shouldn't wrap their conditionals in parentheses.
  #
  # do { ; } â†“while (condition) {
  #
  # â†“switch (foo) {
  #
  # do { ; } â†“while(condition) {
  #
  # } â†“while(condition) {
  #
  # â†“guard (condition) else {
  #
  # â†“for(item in collection) {
  #
  # â†“if ((min...max).contains(value)) {
  #
  # â†“if ((a || b) && (c || d)) {
  
  
  
  - cyclomatic_complexity
  # Complexity of function bodies should be limited.
  #
  # â†“func f1() {
  #   if true {
  #     if true {
  #       if false {}
  #     }
  #   }
  #   if false {}
  #   let i = 0
  #   switch i {
  #   case 1: break
  #   case 2: break
  #   case 3: break
  #   case 4: break
  #   default: break
  #   }
  #   for _ in 1...5 {
  #     guard true else {
  #       return
  #     }
  #   }
  # }
  
  
  - discarded_notification_center_observer
  # When registing for a notification using a block, the 
  # opaque observer that is returned should be stored so it 
  # can be removed later.
  #
  # â†“nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil) { }
  #
  # â†“nc.addObserver(forName: .NSSystemTimeZoneDidChange, object: nil, queue: nil, using: { })
  
  
  
  - dynamic_inline
  # Avoid using 'dynamic' and '@inline(__always)' together.
  #
  # class C {
  # @inline(__always) dynamic â†“func f() {}
  # }
  #
  # class C {
  # @inline(__always) public dynamic â†“func f() {}
  # }
  #
  # class C {
  # @inline(__always) dynamic internal â†“func f() {}
  # }
  #
  # class C {
  # @inline(__always)
  # dynamic â†“func f() {}
  # }
  #
  # class C {
  # @inline(__always)
  # dynamic
  # â†“func f() {}
  # }
  
  
  
  - empty_count
  # Prefer checking `isEmpty` over comparing `count` to zero.
  #
  # [Int]().â†“count == 0
  #
  # [Int]().â†“count > 0
  #
  # [Int]().â†“count != 0
  
  
  
  - empty_parameters
  # Prefer `() -> ` over `Void -> `.
  #
  # let abc: â†“Void -> Void = {}
  #
  # func foo(completion: â†“Void -> Void)
  #
  # func foo(completion: â†“Void throws -> Void)
  #
  # let foo: â†“Void -> () throws -> Void)
  
  
  
  - empty_parentheses_with_trailing_closure
  # When using trailing closures, empty parentheses should be 
  # avoided after the method call.
  #
  # [1, 2].mapâ†“() { $0 + 1 }
  #
  # [1, 2].mapâ†“( ) { $0 + 1 }
  #
  # [1, 2].mapâ†“() { number in
  #   number + 1
  # }
  #
  # [1, 2].mapâ†“(  ) { number in
  #   number + 1
  # }
  
  
  
  - explicit_init
  # Explicitly calling .init() should be avoided.
  #
  # [1].flatMap{Stringâ†“.init($0)}
  #
  # [String.self].map { Type in Typeâ†“.init(1) }
  
  
  
  - fatal_error_message
  # A fatalError call should have a message.
  #
  # func foo() {
  #   â†“fatalError("")
  # }
  #
  # func foo() {
  #   â†“fatalError()
  # }

  
  
  - first_where
  # Prefer using `.first(where:)` over `.filter { }.first` in collections.
  #
  # â†“myList.filter { $0 % 2 == 0 }.first
  #
  # â†“myList.filter({ $0 % 2 == 0 }).first
  #
  # â†“myList.map { $0 + 1 }.filter({ $0 % 2 == 0 }).first
  #
  # â†“myList.map { $0 + 1 }.filter({ $0 % 2 == 0 }).first?.something()
  #
  # â†“myList.filter(someFunction).first
  #
  # â†“myList.filter({ $0 % 2 == 0 })
  # .first
  
  
  
  - for_where
  # `where` clauses are preferred over a single `if` inside a `for`.
  #
  # for user in users {
  #   â†“if user.id == 1 { return true }
  # }
  
  
  
  - force_cast
  # Force casts should be avoided.
  #
  # NSNumber() â†“as! Int
  
  
  
  - force_try
  # Force tries should be avoided.
  #
  # func a() throws {}; â†“try! a()
  
  
  
  - force_unwrapping
  # Force unwrapping should be avoided.
  #
  # let url = NSURL(string: query)â†“!
  #
  # navigationControllerâ†“!.pushViewController(viewController, animated: true)
  #
  # let unwrapped = optionalâ†“!
  #
  # return cellâ†“!
  #
  # let url = NSURL(string: "http://www.google.com")â†“!
  #
  # let dict = ["Boooo": "ðŸ‘»"]func bla() -> String { return dict["Boooo"]â†“! }
  
  
  
  - generic_type_name
  # Generic type name should only contain alphanumeric characters, start with an uppercase character and span between 1 and 20 characters in length.
  #
  # func foo<â†“T_Foo>() {}
  #
  # func foo<â†“TTTTTTTTTTTTTTTTTTTTT>() {}
  #
  # func foo<â†“type>() {}
  


  - implicit_getter
  # Computed read-only properties should avoid using the get keyword.
  #
  # class Foo {
  #   var foo: Int {
  #     â†“get {
  #       return 20
  #     }
  #   }
  # }



  - large_tuple
  # Tuples shouldn't have too many members. Create a custom type instead.
  #
  # â†“let foo: (Int, Int, Int)
  #
  # func foo(â†“bar: (Int, Int, Int))
  #
  # func foo() -> â†“(Int, Int, Int)
  #
  # func foo() throws -> â†“(Int, â†“(String, String, String), Int) {}
  #
  # func getDictionaryAndInt() -> (Dictionary<Int, â†“(String, String, String)>, Int)?
  
  
  
  - leading_whitespace
  # Files should not contain leading whitespace.
  
  
  
  - legacy_cggeometry_functions
  # Struct extension properties and methods are preferred over legacy functions
  #
  # â†“CGRectGetWidth(rect)
  #
  # â†“CGRectIsNull(rect)
  #
  # â†“CGRectIntersectsRect(rect1, rect2)
  
  
  
  - legacy_constant
  # Struct-scoped constants are preferred over legacy global constants.
  #
  # â†“CGRectInfinite
  #
  # â†“CGSizeZero
  #
  # â†“CGRectNull
  #
  # â†“CGFloat(M_PI)
  
  
  
  - legacy_constructor
  # Swift constructors are preferred over legacy convenience functions.
  #
  # â†“CGPointMake(10, 10)
  #
  # â†“CGSizeMake(aWidth, aHeight)
  #
  # â†“NSMakeRect(xVal, yVal, width, height)
  #
  # â†“NSEdgeInsetsMake(top, left, bottom, right)  
  
  
  
  - line_length
  # Lines should not span too many characters.
  
  
  
  - mark
  # MARK comment should be in valid format.
  #
  # â†“//MARK: bad
  #
  # â†“//  MARK: bad
  #
  # â†“// MARK:  bad
  #
  # â†“// MARK:bad
  #
  # â†“// MARK: -bad
  #
  # â†“//MARK: - bad
  #
  # â†“//MARK:- bad

  
  
  - nesting
  # Types should be nested at most 1 level deep, and statements should be nested at most 5 levels deep.
  #
  # class A { class B { â†“class C {} } }
  #
  # struct A { struct B { â†“struct C {} } }
  #
  # enum A { enum B { â†“enum C {} } }
  #
  # func func0() {
  #   func func1() {
  #     func func2() {
  #       func func3() {
  #         func func4() { 
  #           func func5() {
  #             â†“func func6() {
  #             }
  #           }
  #         }
  #       }
  #     }
  #   }
  # }
  
  
  
  # - opening_brace
  # Opening braces should be preceded by a single space and on the same line as the declaration.
  #
  # func abc(â†“){
  # }
  #
  # func abc()â†“
  #   { }
  # 
  # [].map(â†“){ $0 }
  # 
  # [].mapâ†“( { } )
  #
  # if let a = b{ }
  #
  # while a == b{ }
  #
  # guard let a = b else{ }
  
  
  
  - operator_usage_whitespace
  # Operators should be surrounded by a single whitespace when they are being used.
  #
  # let foo = 1â†“+2
  #
  # let foo = 1â†“   + 2
  #
  # let foo = 1â†“   +    2
  #
  # let foo = 1â†“ +    2
  #
  # let fooâ†“=1â†“+2
  #
  # let foo = barâ†“??0
  
  
  
  - operator_whitespace
  # Operators should be surrounded by a single whitespace when defining them.
  #
  # â†“func <|(lhs: Int, rhs: Int) -> Int {}
  #
  # â†“func <|<<A>(lhs: A, rhs: A) -> A {}
  #
  # â†“func <|  (lhs: Int, rhs: Int) -> Int {}
  
  
  
  - redundant_discardable_let
  # Prefer `_ = foo()` over `let _ = foo()` when discarding a result from a function.
  #
  # â†“let _ = foo()
  #
  # if _ = foo() { â†“let _ = bar() }
  
  
  
  - redundant_nil_coalescing
  # nil coalescing operator is only evaluated if the lhs is nil, coalescing operator with nil as rhs is redundant
  #
  # - var myVar: Int? = nil
  # myVarâ†“ ?? nil
  
  
  
  - redundant_optional_initialization
  # Initializing an optional variable with nil is redundant.
  #
  # var myVar: Int?â†“ = nil
  #
  # var myVar: Optional<Int>â†“ = nil
  #
  # var myVar: Int?â†“=nil
  #
  # var myVar: Optional<Int>â†“=nil
  
  
  
  - redundant_string_enum_value
  # String enum values can be omitted when they are equal to the enumcase name.
  #
  # enum Numbers: String {
  #   case one = â†“"one"
  #   case two = â†“"two"
  # }
  #
  # enum Numbers: String {
  #   case one = â†“"one", two = â†“"two"
  # }
  
  
  
  - redundant_void_return
  # Returning Void in a function declaration is redundant.
  #
  # func foo()â†“ -> Void {}
  #
  # protocol Foo {
  #   func foo()â†“ -> Void
  # }
  #
  # func foo()â†“ -> () {}
  #
  # protocol Foo {
  #   func foo()â†“ -> ()
  # }
  
  
  
  - return_arrow_whitespace
  # Return arrow and return type should be separated by a single space or on a separate line.
  #
  # func abc()â†“->Int {}
  #
  # func abc()â†“->[Int] {}
  #
  # func abc()â†“->(Int, Int) {}
  #
  # func abc()â†“-> Int {}
  #
  # func abc()â†“ ->Int {}
  #
  # var abc = {(param: Int)â†“ ->Bool in }
  #
  # var abc = {(param: Int)â†“->Bool in }
  
  
  
  - shorthand_operator
  # Prefer shorthand operators (+=, -=, *=, /=) over doing the operation and assigning.
  #
  # â†“foo = foo - 1
  #
  # â†“foo = foo - aVariable
  #
  # â†“foo = foo - bar.method()
  #
  # â†“foo.aProperty = foo.aProperty - 1
  
  
  
  - sorted_imports
  # Imports should be sorted.
  #
  # import AAA
  # import ZZZ
  # import â†“BBB
  # import CCC
  
  
  
  - statement_position
  # Else and catch should be on the same line, one space after the previous declaration.
  #
  # â†“}else if {
  #
  # â†“}  else {
  #
  # â†“}
  # catch {
  #
  # â†“}
  #     catch {
  
  
  
  - syntactic_sugar
  # Shorthand syntactic sugar should be used, i.e. [Int] instead of Array<Int>
  #
  # let x: â†“Array<String>
  #
  # let x: â†“Dictionary<Int, String>
  #
  # let x: â†“Optional<Int>
  #
  # let x: â†“ImplicitlyUnwrappedOptional<Int>
  
  
  
  - trailing_comma
  # Multi-line collection literals should have trailing commas
  
  
  
  - trailing_newline
  # Files should have a single trailing newline.
  
  
  
  - trailing_semicolon
  # Lines should not have trailing semicolons.
  #
  # let a = 0â†“
  
  
  
  - trailing_whitespace
  # Lines should not have trailing whitespace.
  
  
  
  - type_name
  # Type name should only contain alphanumeric characters, start with an uppercase character and span between 3 and 40 characters in length.
  
  

  - unused_enumerated
  # When the index or the item is not used, `.enumerated()` can be removed.
  #
  # for (â†“_, foo) in bar.enumerated() { }
  #
  # for (â†“_, foo) in abc.bar.enumerated() { }
  #
  # for (â†“_, foo) in abc.something().enumerated() { }
  #
  # for (idx, â†“_) in bar.enumerated() { }
  
  
  
  - unused_optional_binding
  # Prefer `!= nil` over `let _ =`
  #
  # if let â†“_ = Foo.optionalValue { }
  #
  # if let a = Foo.optionalValue, let â†“_ = Foo.optionalValue2 { }
  #
  # if let â†“(_, _, _) = getOptionalTuple(), let bar = Foo.optionalValue { }
  #
  # guard let a = Foo.optionalValue, let â†“_ = Foo.optionalValue2 { }

  
  
  - vertical_parameter_alignment
  # Function parameters should be aligned vertically if they're in multiple lines in a declaration.
  #
  # func validateFunction(_ file: File, kind: SwiftDeclarationKind,
  #                    â†“dictionary: [String: SourceKitRepresentable]) { }
  #
  # func validateFunction(_ file: File, kind: SwiftDeclarationKind,
  #                        â†“dictionary: [String: SourceKitRepresentable]) { }
  #
  # func validateFunction(_ file: File,
  #                   â†“kind: SwiftDeclarationKind,
  #                   â†“dictionary: [String: SourceKitRepresentable]) { }
  
  
  
  - vertical_whitespace
  # Limit vertical whitespace to a single empty line.
  
  
  
  - void_return
  # Prefer `-> Void` over `-> ()`.
  #
  # let abc: () -> â†“() = {}
  #
  # func foo(completion: () -> â†“())
  #
  # func foo(completion: () -> â†“(   ))
  #
  # let foo: (ConfigurationTests) -> () throws -> â†“())



  - legacy_hashing
  # Prefer using the `hash(into:)` function instead of overriding `hashValue`
  # struct Foo: Hashable {
  #    let bar: Int = 10
  #
  #    public â†“var hashValue: Int {
  #        return bar
  #    }
  #}



  - last_where
  # Prefer using `.last(where:)` over `.filter { }.last` in collections.
  # â†“myList.filter { $0 % 2 == 0 }.last
  #
  # â†“myList.filter({ $0 % 2 == 0 }).last
  #
  # â†“myList.map { $0 + 1 }.filter({ $0 % 2 == 0 }).last



  - trailing_closure
  # Trailing closure syntax should be used whenever possible.
  #  â†“foo.map({ $0 + 1 })
  #
  #  â†“foo.reduce(0, combine: { $0 + 1 })
  #
  #  â†“offsets.sorted(by: { $0.offset < $1.offset })



  - legacy_random
  # Prefer using `type.random(in:)` over legacy functions.
  # instead of arc4random, arc4random_uniform, and drand48.
  #  â†“arc4random(10)
  #
  #  â†“arc4random_uniform(83)
  #
  #  â†“drand48(52)



  - inert_defer
  # If defer is at the end of its parent scope, it will be executed right where it is anyway.
  #   func example0() {
  #      â†“defer { /* deferred code */ }
  #   }
  #
  #  func example1() {
  #    â†“defer { /* deferred code */ }
  #      // comment
  #  }
  #
  #  func example2() {
  #      if condition {
  #          â†“defer { /* deferred code */ }
  #          // comment
  #      }
  #  }



  - toggle_bool
  # Prefer `someBool.toggle()` over `someBool = !someBool`.
  #  â†“someBool = !someBool. Requires Swift 4.2.



  - identical_operands
  # Comparing two identical operands is likely a mistake.
  #  â†“self.aProperty == aProperty
  #
  #  â†“lhs.aProperty == rhs.aProperty



  - collection_alignment
  # All elements in a collection literal should be vertically aligned
  #  let abc = [
  #      "alpha": "a",
  #       â†“"beta": "b",
  #      "gamma": "g",
  #      "delta": "d",
  #    â†“"epsilon": "e"
  #  ]



  #  let meals = [
  #      "breakfast": "oatmeal",
  #      "lunch": "sandwich",
  #         â†“"dinner": "burger"
  #  ]



  - redundant_objc_attribute
  #   Objective-C attribute (@objc) is redundant in declaration.
  #  @objc
  #  extension Foo {
  #      â†“@objc
  #      var bar: Int {
  #          return 0
  #      }
  #  }



  - unused_control_flow_label
  # Unused control flow label should be removed.
  #  â†“loop: for x in array { break }
  #
  #  â†“label: switch number {
  #  case 1: print("1")
  #  case 2: print("2")
  #  default: break
  #  }



  - deployment_target
  # Availability checks or attributes shouldn't be using older versions that are satisfied by the deployment target.
  #  â†“@available(iOS 6.0, macOS 10.12, *)
  #  class A {}
  #
  #  if â†“#available(iOS 6.0, *) {}



  - nsobject_prefer_isequal
  # NSObject subclasses should implement isEqual instead of ==.
  #  class AClass: NSObject {
  #      override func isEqual(_ object: Any?) -> Bool {
  #          guard let other = object as? AClass else {
  #              return false
  #          }
  #          return true
  #      }
  #
  #      â†“static func ==(lhs: AClass, rhs: AClass) -> Bool {
  #          return false
  #      }
  #  }



  - contains_over_first_not_nil
  # Prefer `contains` over `first(where:) != nil` and `firstIndex(where:) != nil`.
  #  â†“myList.first { $0 % 2 == 0 } != nil
  #
  #  â†“myList.first(where: { $0 % 2 == 0 }) != nil
  #
  #  â†“myList.map { $0 + 1 }.first(where: { $0 % 2 == 0 }) != nil



  - unused_capture_list
  # Unused reference in a capture list should be removed.
  #  [1, 2].map { [â†“weak self] num in
  #      print(num)
  #  }
  #
  #  let failure: Failure = { [weak self, â†“unowned delegate = self.delegate!] foo in
  #      self?.handle(foo)
  #  }



  - unowned_variable_capture
  # Prefer capturing references as weak to avoid potential crashes.
  #  foo { [â†“unowned self] in _ }
  #
  #  foo { [â†“unowned bar] in _ }
  #
  #  foo { [bar, â†“unowned self] in _ }



  - duplicate_enum_cases
  # Enum can't contain multiple cases with the same name.
  #  enum PictureImport {
  #  case â†“add(image: UIImage)
  #  case addURL(url: URL)
  #  case â†“add(data: Data)
  #  }



  - legacy_multiple
  # Prefer using the `isMultiple(of:)` function instead of using the remainder operator (`%`).
  #  cell.contentView.backgroundColor = indexPath.row â†“% 2 != 0 ? .gray: .white
  #
  #  guard count â†“% 2 == 0 else { throw DecodingError.dataCorrupted(...) }



  - unused_declaration
  # Declarations should be referenced at least once within all files linted.
  #  struct Item {}
  #  struct â†“ResponseModel: Codable {
  #      let â†“items: [Item]
  #
  #      enum â†“CodingKeys: String {
  #          case items = "ResponseItems"
  #      }
  #  }



  - no_space_in_method_call
  # Don't add a space between the method name and the parentheses.
  #  object.fooâ†“ (value: 1)
  #
  #  object.fooâ†“ () {}
  #
  #  object.fooâ†“     ()



  - contains_over_filter_count
  # Prefer `contains` over comparing `filter(where:).count` to 0.
  #  let result = â†“myList.filter(where: { $0 % 2 == 0 }).count > 0
  #
  #  let result = â†“myList.filter { $0 % 2 == 0 }.count > 0



  - contains_over_filter_is_empty
  # Prefer `contains` over using `filter(where:).isEmpty`
  #  let result = â†“myList.filter(where: { $0 % 2 == 0 }).isEmpty
  #
  #  let result = !â†“myList.filter(where: { $0 % 2 == 0 }).isEmpty



  - empty_collection_literal
  # Prefer checking `isEmpty` over comparing collection to an empty array or dictionary literal.
  #  myArrayâ†“ == []
  #
  #  myArrayâ†“ != []
  #
  #  myArrayâ†“ == [ ]
  #
  #  myDictâ†“ == [:]



#  - valid_ibinspectable
#  # @IBInspectable should be applied to variables only, have its type explicit and be of a supported type
#  #
#  # @IBInspectable private â†“let count: Int
#  #
#  # @IBInspectable private â†“var count = 0
#  #
#  # @IBInspectable private â†“var count: Int?
#  #
#  # @IBInspectable private â†“var x: ImplicitlyUnwrappedOptional<Int>



#  - private_outlet
#  # IBOutlets should be private to avoid leaking UIKit to higher layers.
#  #
#  # class Foo {
#  #   @IBOutlet â†“var label: UILabel?
#  # }



#  - missing_docs
#  # Public declarations should be documented.
#  #
#  # â†“public func a() {}
#  #
#  # â†“// regular comment
#  # public func a() {}
#  #
#  # â†“/* regular comment */
#  # public func a() {}
#  #
#  # /// docs
#  # public protocol A {
#  # â†“// no docs
#  # var b: Int { get } }
#  # /// docs
#  # public struct C: A {
#  #
#  # â†“public let b: Int
#  # }



#  - implicitly_unwrapped_optional
#  # Implicitly unwrapped optionals should be avoided when possible.
#  #
#  # let label: UILabel!
#  #
#  # let IBOutlet: UILabel!
#  #
#  # let labels: [UILabel!]
#  #
#  # var ints: [Int!] = [42, nil, 42]
#  #
#  # let label: IBOutlet!



#  - identifier_name
#  # Identifier names should only contain alphanumeric characters and start with a lowercase character or should only contain capital letters. In an exception to the above, variable names may start with a capital letter when they are declared static and immutable. Variable names should not be too long or too short.
#  #
#  # â†“let MyLet = 0
#  #
#  # â†“let _myLet = 0
#  #
#  # private â†“let myLet_ = 0
#  #
#  # â†“let myExtremelyVeryVeryVeryVeryVeryVeryLongLet = 0
#  #
#  # â†“let i = 0
#  #
#  # enum Foo { case â†“MyEnum }
#  #
#  # â†“func IsOperator(name: String) -> Bool
#  #
#  # private â†“let _i = 0



#  - function_body_length
#  # Functions bodies should not span too many lines.



#  - function_parameter_count
#  # Number of function parameters should be low.
#  #
#  # â†“func f(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {}
#  #
#  # â†“func initialValue(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {}
#  #
#  # â†“func f(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int = 2, g: Int) {}
#  #
#  # struct Foo {
#  #   init(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {}
#  #   â†“func bar(a: Int, b: Int, c: Int, d: Int, e: Int, f: Int) {}
#  # }



#  - file_length
#  # Files should not span too many lines.



#  - nslocalizedstring_require_bundle
# rule to ensure calls to
# NSLocalizedString specify the bundle where the strings file is located.



#  - vertical_whitespace_opening_braces
# opt-in rule to warn against empty
# lines after opening braces.



#  - vertical_whitespace_between_cases
#   opt-in rule to enforce a single
#  empty line between switch cases.



#  - vertical_whitespace_closing_braces
# opt-in rule to warn against empty
# lines before closing braces.



#  - required_deinit
# opt-in rule to ensure that all classes have a deinit
# method. The purpose of this is to make memory leak debugging easier so all
# classes have a place to set a breakpoint to track deallocation.



#  - file_types_order
# to specify how the types in a file
# should be sorted.



#  - type_contents_order
# to specify the order of subtypes,
# properties, methods & more within a type.



#  - static_operator
# opt-in rule to enforce that operators are declared as
# static functions instead of free functions.
#  ------



#  - reduce_into
# opt-in rule to encourage the use of reduce(into:_:)
# instead of reduce(_:_:) which is less performant.



#  - nimble_operator
# now warns about beTrue() and beFalse().



#  - reduce_boolean
# rule to prefer simpler constructs over reduce(Boolean).



#  - strong_iboutlet
# opt-in rule to enforce that @IBOutlets are not
# declared as weak.



#  - duplicate_imports
# rule to prevent importing the same module twice.



#  - unused_setter_value
# rule to validate that setter arguments are
# used in properties.



#  - multiline_arguments_brackets
#   opt-in rule to warn against multiline
#  function call arguments with surrounding brackets without newline.



#  - multiline_literal_brackets
#   opt-in rule to warn against multiline
#  literal arrays & dictionaries with surrounding brackets without newline.



#  - multiline_parameters_brackets
#   opt-in rule to warn against multiline
#  function definition parameters with surrounding brackets without newline.



#  - closure_body_length
# opt-in rule to enforce the maximum number
# of lines a closure should have. Requires Swift 4.2.



#  - prohibited_interface_builder
# opt-in rule to validate that @IBOutlets
# and @IBActions are not used.

#  - xct_specific_matcher
  # opt-in rule to enforce specific matchers
  # over XCTAssertEqual and XCTAssertNotEqual.



file_length: 500
function_body_length: 40
identifier_name:
  min_length: 2
  max_length: 20
large_tuple: 3
line_length: 
  warning: 120
  ignores_urls: true
# statement_position: 
#   statement_mode: "uncuddled_else"
trailing_comma:
  mandatory_comma: true
trailing_closure:
  only_single_muted_parameter: true
vertical_whitespace:
  max_empty_lines: 1
nesting:
  type_level: 5
  statement_level: 5
type_name:
  max_length: 1000
cyclomatic_complexity: 11
deployment_target:
  iOS_deployment_target": 11
  
excluded:
  - Pods
  - .idea
  - ./*/Mock/GeneratedMocks.swift
  - Carthage
